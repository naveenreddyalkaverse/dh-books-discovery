'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _bluebird = require('bluebird');

var _bluebird2 = _interopRequireDefault(_bluebird);

var _redislock = require('redislock');

var _redislock2 = _interopRequireDefault(_redislock);

var _semlocks = require('semlocks');

var _semlocks2 = _interopRequireDefault(_semlocks);

var _performanceNow = require('performance-now');

var _performanceNow2 = _interopRequireDefault(_performanceNow);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const LockAcquisitionError = _redislock2.default.LockAcquisitionError;
const LockReleaseError = _redislock2.default.LockReleaseError;

class DistributedLock {
    constructor(config) {
        this.logLevel = config.logLevel;

        this.redisClient = config.redisClient;
        const locksConfig = config.locksConfig;
        _redislock2.default.setDefaults({
            timeout: locksConfig.timeout || 10000,
            retries: locksConfig.retries || 1000,
            delay: locksConfig.delay || 100
        });
    }

    acquire(key) {
        let acquireStartTime = null;
        if (this.logLevel === 'trace') {
            acquireStartTime = (0, _performanceNow2.default)();
            console.log('(DistributedLock) Acquiring lock: ', key);
        }

        const lock = _redislock2.default.createLock(this.redisClient);

        return lock.acquire(key).then(() => {
            if (this.logLevel === 'trace') {
                console.log(`(DistributedLock) Acquired lock '${ key }' in ${ ((0, _performanceNow2.default)() - acquireStartTime).toFixed(3) }ms`);
            }

            return {
                key,
                release: () => {
                    let releaseStartTime = null;
                    if (this.logLevel === 'trace') {
                        releaseStartTime = (0, _performanceNow2.default)();
                        console.log(`(DistributedLock) Releasing lock '${ key }'`);
                    }

                    return lock.release().then(() => {
                        if (this.logLevel === 'trace') {
                            console.log(`(DistributedLock) Released lock '${ key }' in ${ ((0, _performanceNow2.default)() - releaseStartTime).toFixed(3) }ms`);
                        }

                        return true;
                    }).catch(LockReleaseError, error => {
                        console.error(`(DistributedLock) Error in releasing lock '${ key }': `, error);

                        //throw error;
                        return true;
                    });
                }
            };
        }).catch(LockAcquisitionError, error => {
            console.error(`(DistributedLock) Error in acquiring lock '${ key }': `, error);
            return _bluebird2.default.reject({ key, error: true, details: error });
        });
    }

    shutdown() {
        if (this.logLevel === 'trace') {
            console.log('(DistributedLock) Shutting down');
        }

        return true;
    }
}

class LocalLock {
    constructor(config) {
        this.logLevel = config.logLevel;
        this.locks = _semlocks2.default;
    }

    acquire(key) {
        return new _bluebird2.default((resolve, reject) => {
            let acquireStartTime = null;
            if (this.logLevel === 'trace') {
                acquireStartTime = (0, _performanceNow2.default)();
                console.log('(LocalLock) Acquiring Lock: ', key);
            }

            const handle = this.locks.acquire(key, { wait: 200, ttl: 200, priority: 1 }, (err, release) => {
                if (err) {
                    console.error('Error in acquiring lock: ', key, err);
                    reject({ key, error: true, details: err });
                    return;
                }

                if (this.logLevel === 'trace') {
                    console.log('(LocalLock) Acquired Lock: ', key, ((0, _performanceNow2.default)() - acquireStartTime).toFixed(3));
                }

                resolve({
                    key, release: () => {
                        let lockReleaseStartTime = null;

                        if (this.logLevel === 'trace') {
                            lockReleaseStartTime = (0, _performanceNow2.default)();
                            console.log('(LocalLock) Releasing Lock: ', key);
                        }

                        return release(handle, key);
                    }
                });
            });
        });
    }

    shutdown() {
        if (this.logLevel === 'trace') {
            console.log('Shutting down: LocalLock');
        }

        delete this.locks;
        return true;
    }
}

class Lock {
    constructor(config) {
        this.logLevel = config.logLevel;

        let mode = 'local';
        if (config.locksConfig && config.locksConfig.type === 'redis') {
            mode = 'redis';
        }

        if (mode === 'redis') {
            this.instance = new DistributedLock(config);
        } else {
            this.instance = new LocalLock(config);
        }
    }

    acquire(key) {
        if (this.logLevel === 'trace') {
            const startTime = (0, _performanceNow2.default)();

            return _bluebird2.default.resolve(this.instance.acquire(key)).then(result => {
                console.log('Acquired lock: ', key, result, ((0, _performanceNow2.default)() - startTime).toFixed(3));
                return result;
            });
        }

        return this.instance.acquire(key);
    }

    usingLock(operation, key, lockHandle, log) {
        let finalResult = null;

        const startTime = (0, _performanceNow2.default)();

        if (lockHandle) {
            return _bluebird2.default.resolve(operation(lockHandle)).then(result => {
                if (log) log(((0, _performanceNow2.default)() - startTime).toFixed(3));

                return result;
            });
        }

        let opStartTime = null;

        let lockReleased = false;

        return _bluebird2.default.resolve(this.acquire(key)).then(handle => {
            lockHandle = handle;

            opStartTime = (0, _performanceNow2.default)();

            return operation(lockHandle);
        }).then(result => {
            if (this.logLevel === 'trace') {
                console.log('Operation time: ', ((0, _performanceNow2.default)() - opStartTime).toFixed(3));
            }

            finalResult = result;

            return lockHandle.release();
        }).then(() => {
            if (log) log(((0, _performanceNow2.default)() - startTime).toFixed(3));

            lockReleased = true;

            return finalResult;
        }).finally(() => {
            if (!lockReleased && lockHandle) {
                return lockHandle.release();
            }

            return true;
        });
    }

    shutdown() {
        if (this.logLevel === 'trace') {
            console.log('Shutting down: Lock');
        }

        return this.instance.shutdown();
    }
}
exports.default = Lock;
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _stringify = require('babel-runtime/core-js/json/stringify');

var _stringify2 = _interopRequireDefault(_stringify);

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _bluebird = require('bluebird');

var _bluebird2 = _interopRequireDefault(_bluebird);

var _chalk = require('chalk');

var _chalk2 = _interopRequireDefault(_chalk);

var _events = require('events');

var _performanceNow = require('performance-now');

var _performanceNow2 = _interopRequireDefault(_performanceNow);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const FlushSchedulerKey = 'aggregate-flusher';

class DistributedCache {
    constructor(config) {
        this.instanceName = config.instanceName || 'default';
        this.logLevel = config.logLevel;
        this.redisClient = config.redisClient;
        this.keyPrefix = `${ this.instanceName }:agg:`;
    }

    getKey(key) {
        return `${ this.keyPrefix }${ key }`;
    }

    store(key, data) {
        if (this.logLevel === 'trace') {
            console.log('(DistributedCache) Storing key: ', key, this.getKey(key));
        }

        return this.redisClient.setAsync(this.getKey(key), (0, _stringify2.default)(data)).then(() => data);
    }

    retrieve(key) {
        return this.redisClient.getAsync(this.getKey(key)).then(data => {
            if (!_lodash2.default.isUndefined(data) && !_lodash2.default.isNull(data) && _lodash2.default.isString(data)) {
                return JSON.parse(data);
            }

            return null;
        });
    }

    remove(key) {
        if (this.logLevel === 'trace') {
            console.log('(DistributedCache) Removing key: ', key, this.getKey(key));
        }

        return this.redisClient.delAsync(this.getKey(key));
    }

    keys() {
        // TODO: probably SCAN based implementation is better, but there may not be many keys too...
        return this.redisClient.keysAsync(`${ this.keyPrefix }*`).then(keys => keys.map(key => key.substring(this.keyPrefix.length, key.length)));
    }

    shutdown() {
        if (this.logLevel === 'trace') {
            console.log('Shutting down: DistributedCache');
        }

        return true;
    }
}

class LocalCache {
    constructor(config) {
        this.logLevel = config.logLevel;

        this.keysCount = 0;
        this.cache = {};
    }

    store(key, data) {
        if (this.logLevel === 'trace') {
            console.log('(LocalCache) Storing key: ', key, this.keysCount);
        }

        this.cache[key] = data;
        this.keysCount++;
        return data;
    }

    retrieve(key) {
        return this.cache[key];
    }

    remove(key) {
        this.cache[key] = undefined;
        delete this.cache[key];
        this.keysCount--;

        if (this.logLevel === 'trace') {
            console.log('(LocalCache) Removed key: ', key, this.keysCount);
        }

        return true;
    }

    keys() {
        return _lodash2.default.keys(this.cache);
    }

    shutdown() {
        delete this.cache;
        return true;
    }
}

class Cache {
    constructor(config, indexer, lock) {
        this.logLevel = config.logLevel;

        let mode = 'local';
        if (config.cacheConfig) {
            const cacheConfig = config.cacheConfig;
            if (cacheConfig.type === 'redis' || config.redisClient) {
                mode = 'redis';
            }

            if (cacheConfig.flushTimeout) {
                this.flushTimeout = cacheConfig.flushTimeout;
            }
        } else {
            this.flushTimeout = 10000;
        }

        if (mode === 'redis') {
            this.instance = new DistributedCache(config);
        } else {
            this.instance = new LocalCache(config);
        }

        this.scheduleHandle = null;
        this.schedule = null;

        this.indexer = indexer;
        this.lock = lock;
        this.eventEmitter = new _events.EventEmitter();

        this._flushing = false;
    }

    store(key, data) {
        // if no schedule then create a schedule
        if (!this.schedule) {
            if (this.logLevel === 'trace') {
                console.log('Store: Scheduling Flush: No Keys');
            }

            this.scheduleFlush();
        }

        if (this.logLevel === 'trace') {
            const startTime = (0, _performanceNow2.default)();
            return _bluebird2.default.resolve(this.instance.store(key, data)).then(result => {
                console.log('Stored key: ', key, ((0, _performanceNow2.default)() - startTime).toFixed(3));
                return result;
            });
        }

        return this.instance.store(key, data);
    }

    retrieve(key) {
        if (this.logLevel === 'trace') {
            const startTime = (0, _performanceNow2.default)();
            return _bluebird2.default.resolve(this.instance.retrieve(key)).then(result => {
                console.log('Retrieved key: ', key, ((0, _performanceNow2.default)() - startTime).toFixed(3));
                return result;
            });
        }

        return this.instance.retrieve(key);
    }

    remove(key) {
        if (this.logLevel === 'trace') {
            const startTime = (0, _performanceNow2.default)();
            return _bluebird2.default.resolve(this.instance.remove(key)).then(result => {
                console.log('Removed key: ', key, ((0, _performanceNow2.default)() - startTime).toFixed(3));
                return result;
            });
        }

        return this.instance.remove(key);
    }

    keys() {
        return this.instance.keys();
    }

    scheduleFlush() {
        console.log(_chalk2.default.yellow('Scheduling Flush'));

        const operation = () => {
            if (!this.schedule) {
                this.scheduleHandle = _lodash2.default.delay(this.flush.bind(this), this.flushTimeout);
                this.schedule = true;

                console.log(_chalk2.default.yellow(`Scheduled Flush: ${ this.scheduleHandle }`));
            } else {
                console.log(_chalk2.default.yellow('Schedule already exist'));
            }

            return true;
        };

        return this.lock.usingLock(operation, FlushSchedulerKey);
    }

    removeFlushSchedule() {
        console.log(_chalk2.default.yellow('Removing Flush Schedule'));
        const operation = () => {
            if (this.schedule) {
                if (this.scheduleHandle) {
                    clearTimeout(this.scheduleHandle);
                }

                this.scheduleHandle = null;
                this.schedule = null;
            }

            return true;
        };

        return this.lock.usingLock(operation, FlushSchedulerKey, null, () => console.log(_chalk2.default.yellow('Removed Flush Schedule')));
    }

    ensureFlushComplete() {
        return new _bluebird2.default((resolve, reject) => {
            if (!this._flushing) {
                resolve(true);
                return true;
            }

            const _this = this;

            const checkFlushComplete = () => {
                if (!_this._flushing) {
                    return resolve(true);
                }

                _lodash2.default.delay(checkFlushComplete, 5000);
                return true;
            };

            _lodash2.default.delay(checkFlushComplete, 5000);
            return true;
        });
    }

    flush(noSchedule) {
        // flush started
        this._flushing = true;

        console.log();
        console.log(_chalk2.default.yellow('------------------------------------------------------'));
        console.log(_chalk2.default.yellow('Starting aggregate flush...'));

        const flushStartTime = (0, _performanceNow2.default)();

        if (this.logLevel === 'trace') {
            console.log('Flushing: AggregatorCache. NoSchedule: ', noSchedule);
        }

        return _bluebird2.default.resolve(this.keys()).then(keys => {
            if (!keys || _lodash2.default.isEmpty(keys)) {
                if (this.logLevel === 'trace') {
                    console.log('Removing Flush Schedule: found no keys');
                }

                return this.removeFlushSchedule();
            }

            return _bluebird2.default.map(keys, key => this.indexer.flushAggregate(key), { concurrency: 1 }).then(() => {
                if (!noSchedule) {
                    this.schedule = null;
                    this.scheduleHandle = null;

                    return this.scheduleFlush();
                }

                if (this.logLevel === 'trace') {
                    console.log('Removing Flush Schedule: noSchedule: ', noSchedule);
                }

                return this.removeFlushSchedule();
            });
        }).finally(() => {
            console.log(_chalk2.default.yellow(`...Finished aggregate flush in: ${ ((0, _performanceNow2.default)() - flushStartTime).toFixed(3) }`));
            console.log(_chalk2.default.yellow('------------------------------------------------------'));
            this._flushing = false;
        });
    }

    shutdown() {
        // first flush, then shutdown the instance
        if (this.logLevel === 'trace') {
            console.log('Shutting down: AggregatorCache');
        }

        return _bluebird2.default.resolve(this.ensureFlushComplete()).then(() => this.removeFlushSchedule()).then(() => this.flush(true)).then(() => this.instance.shutdown()).then(() => {
            console.log('Shut down: AggregatorCache');

            return true;
        });
    }
}
exports.default = Cache;
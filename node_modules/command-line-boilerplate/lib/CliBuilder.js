'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Command = undefined;

var _commander = require('commander');

var _commander2 = _interopRequireDefault(_commander);

var _bluebird = require('bluebird');

var _bluebird2 = _interopRequireDefault(_bluebird);

var _child_process = require('child_process');

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _chalk = require('chalk');

var _chalk2 = _interopRequireDefault(_chalk);

var _gracefulReadlink = require('graceful-readlink');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function handleCommandResponse(promise) {
    _bluebird2.default.resolve(promise).then(result => {
        console.log(_chalk2.default.green('Response: '), result);
        process.exit(0);
    }).catch(error => {
        console.error(_chalk2.default.red('Error: '), error, error.stack);
        process.exit(1);
    });
}

class Command {
    constructor(name) {
        this.name = name;
        this.command = _commander2.default.command(name);
    }

    option(flags, description, fn, defaultValue) {
        this.command.option(flags, description, fn, defaultValue);

        return this;
    }

    description(text) {
        this.command.description(text);

        return this;
    }

    action(fn, params) {
        if (params && params.memorySize) {
            this.command.option('--spawned', 'Indicates that process is spawned one');
        }

        this.command.action(args => {
            global.currentCommand = this.name;

            if (!params || !params.watch) {
                return handleCommandResponse(fn(args));
            }

            // it's a long running process
            if (params.memorySize && !args.spawned) {
                // we need to spawn a child process
                const executable = process.argv[1];

                // In case of globally installed, get the base dir where executable
                // command file should be located at
                let link = (0, _gracefulReadlink.readlinkSync)(executable);

                // when symbolink is relative path
                if (link !== executable && link.charAt(0) !== '/') {
                    link = _path2.default.join((0, _path.dirname)(executable), link);
                }

                let isJSExecutable = false;
                if (link.match(/\.js$/)) {
                    isJSExecutable = true;
                }

                let processArgs = process.argv.slice(2);
                processArgs.push('--spawned');

                let proc;
                if (isJSExecutable) {
                    // add executable arguments to spawn
                    processArgs = (process.execArgv || []).concat(['--optimize_for_size', `--max_old_space_size=${ params.memorySize }`, `--gc_interval=${ params.gcInterval || 50 }`, link]).concat(processArgs);

                    proc = (0, _child_process.spawn)('node', processArgs, { stdio: 'inherit', customFds: [0, 1, 2] });
                } else {
                    if (process.platform !== 'win32') {
                        proc = (0, _child_process.spawn)(link, processArgs, { stdio: 'inherit', customFds: [0, 1, 2] });
                    } else {
                        processArgs.unshift(link);
                        proc = (0, _child_process.spawn)(process.execPath, processArgs, { stdio: 'inherit' });
                    }
                }

                proc.on('close', process.exit.bind(process));
                proc.on('error', err => {
                    if (err.code === 'ENOENT') {
                        console.error('\n  %s(1) does not exist, try --help\n', link);
                    } else if (err.code === 'EACCES') {
                        console.error('\n  %s(1) not executable. try chmod or run with root\n', link);
                    }
                    process.exit(1);
                });

                // Store the reference to the child process
                //this.runningCommand = proc;
            } else {
                    // if it is spawned process or memory size is not set, we behave normal
                    return fn(args);
                }

            return null;
        });

        return this;
    }
}
exports.Command = Command;